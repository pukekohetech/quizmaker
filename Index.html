<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Quiz JSON Builder for BCATS Safety Assessments</title>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 1000px;
    margin: 20px auto;
    line-height: 1.5;
    background: #f4f6fb;
  }
  h1 {
    color: #1b3a57;
    background: linear-gradient(90deg, #1b3a57, #2969b0);
    color: #fff;
    padding: 12px 18px;
    border-radius: 8px;
    font-size: 22px;
  }
  h2 {
    color: #1b3a57;
    border-bottom: 2px solid #d0d7e2;
    padding-bottom: 4px;
  }
  label { display: block; margin-top: 10px; font-weight: bold; font-size: 13px; }
  input, textarea, select {
    width: 100%;
    padding: 6px 8px;
    margin-top: 4px;
    box-sizing: border-box;
    border-radius: 4px;
    border: 1px solid #ccd2e0;
    font-size: 13px;
  }
  textarea { height: 100px; }
  .section {
    border: 1px solid #c3d0ea;
    padding: 15px;
    margin-bottom: 20px;
    border-radius: 10px;
    background: #e9f1ff;
  }

  /* Collapsible headers for sections & questions */
  .section-header,
  .question-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  .section-header-title,
  .question-header-title {
    font-weight: bold;
    flex: 1;
  }

  /* Visible collapse button */
  .collapse-btn {
    border: 2px solid #1b3a57;
    background: #ffffff;
    color: #1b3a57;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 0 2px rgba(27, 58, 87, 0.08);
  }
  .collapse-btn:hover {
    background: #1b3a57;
    color: #ffffff;
  }
  .section.collapsed .collapse-btn,
  .question.collapsed .collapse-btn {
    background: #dfe6f5;
    color: #1b3a57;
  }

  .collapsed .section-body,
  .collapsed .question-body {
    display: none;
  }
  .collapsed {
    opacity: 0.95;
  }

  .teacher {
    border: 1px solid #cfd8e3;
    padding: 10px;
    margin: 8px 0;
    background: #ffffff;
    border-radius: 6px;
    position: relative;
  }
  .question {
    border: 2px solid #b0c4ff;
    padding: 12px;
    margin: 12px 0;
    background: #ffffff;
    border-radius: 8px;
    position: relative;
    box-shadow: 0 1px 3px rgba(0,0,0,0.04);
  }
  .question:nth-child(odd) {
    border-left: 6px solid #4c8bf5;
  }
  .question:nth-child(even) {
    border-left: 6px solid #2ecc71;
  }

  /* Drag & drop visuals */
  .question.dragging {
    opacity: 0.6;
    border-style: dashed;
  }
  .question.drop-target {
    outline: 2px dashed #1b3a57;
  }

  .rubric-row, .option-row {
    border: 1px solid #dde3f0;
    padding: 10px;
    margin: 8px 0;
    background: #fdfdff;
    border-radius: 6px;
    position: relative;
  }
  .options {
    border: 1px solid #ffd8a8;
    background: #fff7e6;
    padding: 10px;
    border-radius: 8px;
    margin-top: 10px;
  }
  .options h4 {
    margin: 0 0 6px;
    color: #b35b00;
  }
  .rubric {
    border: 1px solid #c3e6cb;
    background: #f0fff4;
    padding: 10px;
    border-radius: 8px;
    margin-top: 10px;
  }
  .rubric h4 {
    margin: 0 0 6px;
    color: #2b7a32;
  }
  .remove {
    color: #e74c3c;
    cursor: pointer;
    font-weight: bold;
  }
  button {
    padding: 7px 12px;
    margin: 6px 4px 6px 0;
    background: #3498db;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
  }
  button:hover { background: #2980b9; }
  .add-btn { background: #27ae60; }
  .add-btn:hover { background: #1e8449; }
  .secondary-btn { background: #7f8c8d; }
  .secondary-btn:hover { background: #626e70; }
  .controls { margin: 16px 0 24px; }

  .image-drop {
    margin-top: 6px;
    padding: 10px;
    border-radius: 6px;
    border: 2px dashed #9aa5c3;
    background: #f3f5ff;
    font-size: 12px;
    text-align: center;
    color: #3b4a73;
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s;
  }
  .image-drop span {
    display: block;
  }
  .image-drop.dragover {
    background: #dbe4ff;
    border-color: #4c6fff;
  }
  .image-filename-note {
    font-size: 11px;
    color: #666;
    margin-top: 2px;
  }

  .question-tester {
    margin-top: 10px;
    padding: 8px;
    border-radius: 8px;
    border: 1px dashed #b0bec5;
    background: #fafafa;
    font-size: 12px;
  }
  .question-tester h4 {
    margin: 0 0 6px;
    font-size: 13px;
    color: #37474f;
  }
  .question-tester textarea {
    height: 70px;
  }
  .qTestResult {
    margin-top: 4px;
    font-size: 12px;
    color: #37474f;
    white-space: pre-line;
  }
</style>
</head>
<body>

<h1>Quiz JSON Builder â€“ BCATS Safety Assessments</h1>

<!-- CONTROLS AT THE TOP -->
<div class="controls">
  <input type="file" id="jsonFile" accept="application/json">
  <button type="button" onclick="loadJSONFile()">Load JSON File</button>
  <button type="button" onclick="clearDraft()">Clear Draft</button>
  <button type="button" class="secondary-btn" onclick="expandAllSections()">Expand all assessments & questions</button>
  <button type="button" class="secondary-btn" onclick="collapseAllSections()">Collapse all assessments & questions</button>
  <button type="button" onclick="generateJSON()">Download JSON File</button>
</div>

<!-- GENERAL INFO (NOW COLLAPSIBLE) -->
<div class="section collapsed">
  <div class="section-header">
    <button type="button" class="collapse-btn" onclick="toggleSectionCollapse(this)">â–¸</button>
    <span class="section-header-title">General Information</span>
  </div>
  <div class="section-body">
    <label>APP_ID <input type="text" id="appId" value="US24352_SAFETY"></label>
    <label>VERSION <input type="text" id="version" value="2025"></label>
    <label>APP_TITLE <input type="text" id="appTitle" value="US 24352 â€“ Safety Knowledge"></label>
    <label>APP_SUBTITLE <input type="text" id="appSubtitle" value="PHS - L1 Building â€“ Assessment"></label>

    <label>Deadline Day <input type="number" id="deadlineDay" value="17"></label>
    <label>Deadline Month <input type="number" id="deadlineMonth" value="12"></label>
    <label>Deadline Label <input type="text" id="deadlineLabel" value="Submission deadline"></label>
  </div>
</div>

<!-- TEACHERS (NOW COLLAPSIBLE) -->
<div class="section collapsed">
  <div class="section-header">
    <button type="button" class="collapse-btn" onclick="toggleSectionCollapse(this)">â–¸</button>
    <span class="section-header-title">Teachers</span>
  </div>
  <div class="section-body">
    <div id="teachers"></div>
    <button type="button" class="add-btn" onclick="addTeacher()">+ Add Teacher</button>
  </div>
</div>

<div class="section">
  <h2>Assessments</h2>
  <div id="assessments"></div>
  <button type="button" class="add-btn" onclick="addAssessment()">+ Add Assessment</button>
</div>

<script>
let data = {
  APP_ID: "US24352_SAFETY",
  VERSION: "2025",
  APP_TITLE: "US 24352 â€“ Safety Knowledge",
  APP_SUBTITLE: "PHS - L1 Building â€“ Assessment",
  DEADLINE: { day: 17, month: 12, label: "Submission deadline" },
  TEACHERS: [],
  ASSESSMENTS: []
};

let isLoading = false;

// For drag & drop
let draggedQuestion = null;

// Helper to keep regex flags sane
function sanitizeFlags(flags) {
  const valid = (flags || "").replace(/[^gimsuy]/g, "");
  return [...new Set(valid.split(""))].join("");
}

// Get flags from a rubric row
function getFlagsForRow(row) {
  const select = row.querySelector('.rFlagsSelect');
  const flagsInput = row.querySelector('.rFlags');
  let flags;
  if (select) {
    if (select.value === 'custom') {
      flags = (flagsInput.value.trim() || 'i');
    } else {
      flags = select.value; // can be '', 'i', 'im', 'is'
    }
  } else if (flagsInput) {
    flags = flagsInput.value.trim() || 'i';
  } else {
    flags = 'i';
  }
  return sanitizeFlags(flags || 'i');
}

// ---------- Collapse helpers ----------
function toggleSectionCollapse(btn) {
  const section = btn.closest('.section');
  if (!section) return;
  section.classList.toggle('collapsed');
  btn.textContent = section.classList.contains('collapsed') ? 'â–¸' : 'â–¾';
}

function toggleQuestionCollapse(btn) {
  const q = btn.closest('.question');
  if (!q) return;
  q.classList.toggle('collapsed');
  btn.textContent = q.classList.contains('collapsed') ? 'â–¸' : 'â–¾';
}

// Expand/collapse all assessments & questions
function expandAllSections() {
  const sections = document.querySelectorAll('#assessments > .section');
  sections.forEach(section => {
    section.classList.remove('collapsed');
    const sBtn = section.querySelector('.section-header .collapse-btn');
    if (sBtn) sBtn.textContent = 'â–¾';
    const questions = section.querySelectorAll('.question');
    questions.forEach(q => {
      q.classList.remove('collapsed');
      const qBtn = q.querySelector('.question-header .collapse-btn');
      if (qBtn) qBtn.textContent = 'â–¾';
    });
  });
}

function collapseAllSections() {
  const sections = document.querySelectorAll('#assessments > .section');
  sections.forEach(section => {
    section.classList.add('collapsed');
    const sBtn = section.querySelector('.section-header .collapse-btn');
    if (sBtn) sBtn.textContent = 'â–¸';
    const questions = section.querySelectorAll('.question');
    questions.forEach(q => {
      q.classList.add('collapsed');
      const qBtn = q.querySelector('.question-header .collapse-btn');
      if (qBtn) qBtn.textContent = 'â–¸';
    });
  });
}

// ---------- Drag & drop for questions ----------
function questionDragStart(e) {
  draggedQuestion = this;
  this.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  // Needed in some browsers
  e.dataTransfer.setData('text/plain', '');
}

function questionDragEnd(e) {
  this.classList.remove('dragging');
  document.querySelectorAll('.question.drop-target').forEach(el => el.classList.remove('drop-target'));
  draggedQuestion = null;
}

function questionDragOver(e) {
  e.preventDefault();
  if (!draggedQuestion) return;
  e.dataTransfer.dropEffect = 'move';

  const target = e.currentTarget;
  if (target === draggedQuestion) return;

  document.querySelectorAll('.question.drop-target').forEach(el => el.classList.remove('drop-target'));
  target.classList.add('drop-target');
}

function questionDrop(e) {
  e.preventDefault();
  const target = e.currentTarget;
  if (!draggedQuestion || draggedQuestion === target) return;

  const container = target.parentElement;
  const rect = target.getBoundingClientRect();
  const offset = e.clientY - rect.top;
  const halfway = rect.height / 2;

  if (offset > halfway) {
    container.insertBefore(draggedQuestion, target.nextSibling);
  } else {
    container.insertBefore(draggedQuestion, target);
  }

  target.classList.remove('drop-target');
}

function questionDragLeave(e) {
  e.currentTarget.classList.remove('drop-target');
}

function makeQuestionDraggable(qDiv) {
  qDiv.setAttribute('draggable', 'true');
  qDiv.addEventListener('dragstart', questionDragStart);
  qDiv.addEventListener('dragend', questionDragEnd);
  qDiv.addEventListener('dragover', questionDragOver);
  qDiv.addEventListener('drop', questionDrop);
  qDiv.addEventListener('dragleave', questionDragLeave);
}

// ---------- Teachers ----------
function addTeacher(t = null) {
  const div = document.createElement('div');
  div.className = 'teacher';
  div.innerHTML = `
    <span class="remove" onclick="this.parentElement.remove()">âœ–</span>
    <label>ID <input type="text" class="tId" value="${t ? (t.id || '') : ''}"></label>
    <label>Name <input type="text" class="tName" value="${t ? (t.name || '') : ''}"></label>
    <label>Email <input type="text" class="tEmail" value="${t ? (t.email || '') : ''}"></label>
  `;
  document.getElementById('teachers').appendChild(div);
}

function collectTeachers() {
  data.TEACHERS = Array.from(document.querySelectorAll('.teacher')).map(d => ({
    id: d.querySelector('.tId').value.trim(),
    name: d.querySelector('.tName').value.trim(),
    email: d.querySelector('.tEmail').value.trim()
  }));
}

// ---------- Assessments & Questions ----------
function addAssessment(a = null) {
  const div = document.createElement('div');
  // Start collapsed by default
  div.className = 'section collapsed';
  const titleText = a ? (a.title || a.id || 'Assessment') : 'New Assessment';

  div.innerHTML = `
    <div class="section-header">
      <button type="button" class="collapse-btn" onclick="toggleSectionCollapse(this)">â–¸</button>
      <span class="section-header-title">Assessment â€“ <span class="assHeaderTitle">${titleText}</span></span>
      <span style="margin-left:auto; display:flex; gap:6px; align-items:center;">
        <button type="button" class="secondary-btn" onclick="duplicateAssessment(this)">Duplicate</button>
        <span class="remove" onclick="this.closest('.section').remove()">âœ–</span>
      </span>
    </div>
    <div class="section-body">
      <label>Assessment ID <input type="text" class="assId" value="${a ? (a.id || '') : ''}"></label>
      <label>Title <input type="text" class="assTitle" value="${a ? (a.title || '') : ''}"></label>
      <label>Subtitle <input type="text" class="assSubtitle" value="${a ? (a.subtitle || '') : ''}"></label>
      <label>US Number <input type="text" class="assUSNumber" value="${a ? (a.usNumber || '') : ''}"></label>
      <label>US Version <input type="text" class="assUSVersion" value="${a ? (a.usVersion || '') : ''}"></label>
      <label>Credits <input type="number" class="assCredits" value="${a && a.credits != null ? a.credits : ''}"></label>
      <label>Standard Type
        <select class="assType">
          <option value="">(optional)</option>
          <option value="internal" ${a && a.standardType === 'internal' ? 'selected' : ''}>Internal</option>
          <option value="external" ${a && a.standardType === 'external' ? 'selected' : ''}>External</option>
        </select>
      </label>
      <div class="questions"></div>
      <button type="button" class="add-btn" onclick="addQuestion(this.closest('.section').querySelector('.questions'))">+ Add Question</button>
    </div>
  `;
  document.getElementById('assessments').appendChild(div);

  // keep header title in sync with assessment title
  const titleInput = div.querySelector('.assTitle');
  const headerTitleEl = div.querySelector('.assHeaderTitle');
  titleInput.addEventListener('input', () => {
    headerTitleEl.textContent = titleInput.value || (div.querySelector('.assId').value || 'Assessment');
  });
  const idInput = div.querySelector('.assId');
  idInput.addEventListener('input', () => {
    if (!titleInput.value) {
      headerTitleEl.textContent = idInput.value || 'Assessment';
    }
  });

  if (a && a.questions) a.questions.forEach(q => addQuestion(div.querySelector('.questions'), q));
}

function duplicateAssessment(btn) {
  const assDiv = btn.closest('.section');
  const container = document.getElementById('assessments');
  const clone = assDiv.cloneNode(true);
  clone.classList.add('collapsed');
  const idInput = clone.querySelector('.assId');
  const headerTitleEl = clone.querySelector('.assHeaderTitle');
  const collapseBtn = clone.querySelector('.collapse-btn');

  if (idInput) idInput.value = (idInput.value || '') + '_copy';
  if (headerTitleEl && idInput) headerTitleEl.textContent = idInput.value || headerTitleEl.textContent;
  if (collapseBtn) collapseBtn.textContent = 'â–¸';

  // rewire title/id events for clone
  const titleInput = clone.querySelector('.assTitle');
  if (titleInput && headerTitleEl) {
    titleInput.addEventListener('input', () => {
      headerTitleEl.textContent = titleInput.value || (clone.querySelector('.assId').value || 'Assessment');
    });
  }
  const idInputClone = clone.querySelector('.assId');
  if (idInputClone && headerTitleEl && titleInput) {
    idInputClone.addEventListener('input', () => {
      if (!titleInput.value) {
        headerTitleEl.textContent = idInputClone.value || 'Assessment';
      }
    });
  }

  // make all questions inside the cloned assessment draggable
  clone.querySelectorAll('.question').forEach(q => makeQuestionDraggable(q));

  container.insertBefore(clone, assDiv.nextSibling);
}

// ---------- Questions ----------
function addQuestion(container, q = null) {
  const div = document.createElement('div');
  // start questions collapsed inside collapsed sections
  div.className = 'question collapsed';

  const qIdVal = q ? (q.id || '') : '';
  const headerLabel = qIdVal || 'New question';

  div.innerHTML = `
    <div class="question-header">
      <button type="button" class="collapse-btn" onclick="toggleQuestionCollapse(this)">â–¸</button>
      <span class="question-header-title">Question â€“ <span class="qHeaderTitle">${headerLabel}</span></span>
      <span style="margin-left:auto; display:flex; gap:6px; align-items:center;">
        <button type="button" class="secondary-btn" onclick="duplicateQuestion(this)">Duplicate</button>
        <span class="remove" onclick="this.closest('.question').remove()">âœ–</span>
      </span>
    </div>
    <div class="question-body">
      <label>Question ID <input type="text" class="qId" value="${q ? (q.id || '') : ''}"></label>
      <label>Text (you can use \\n for line breaks)<br>
        <textarea class="qText">${q ? (q.text || '') : ''}</textarea></label>

      <label>Image filename (or blank.jpg)
        <input type="text" class="qImage" value="${q ? (q.image || 'blank.jpg') : 'blank.jpg'}">
        <div class="image-filename-note">This will be written into the JSON. Make sure it matches the actual file name in your images folder.</div>
      </label>
      <div class="image-drop"
          onclick="imageDropClick(this)"
          ondragover="handleImageDragOver(event)"
          ondragleave="handleImageDragLeave(event)"
          ondrop="handleImageDrop(event)">
        <span>ðŸ“· Drag a photo here or click to choose a file</span>
        <input type="file" accept="image/*" class="qImageFile" style="display:none" onchange="handleImageFileSelect(this)">
      </div>

      <label>Hint <input type="text" class="qHint" value="${q ? (q.hint || '') : ''}"></label>
      <label>Type 
        <select class="qType" onchange="toggleOptionsRubric(this)">
          <option value="mc" ${q && q.type === 'mc' ? 'selected' : ''}>Multiple Choice (mc)</option>
          <option value="short" ${q && q.type === 'short' ? 'selected' : ''}>Short answer</option>
          <option value="long" ${q && q.type === 'long' ? 'selected' : ''}>Long answer</option>
        </select>
      </label>
      <label>Max Points <input type="number" class="qPoints" value="${q ? (q.maxPoints || 1) : 1}"></label>

      <div class="options" style="display:block">
        <h4>Options</h4>
        <div class="option-list"></div>
        <button type="button" class="add-btn" onclick="addOptionRow(this.closest('.options').querySelector('.option-list'))">+ Add Option</button>
      </div>

      <div class="rubric" style="display:block">
        <h4>Auto-grading Rubric</h4>
        <div class="rubric-list"></div>
        <button type="button" class="add-btn" onclick="addRubricRow(this.closest('.rubric').querySelector('.rubric-list'))">+ Add Rubric Rule</button>
      </div>

      <div class="question-tester">
        <h4>Test this question with a sample answer</h4>
        <textarea class="qSample" placeholder="Paste a student answer here"></textarea>
        <button type="button" class="secondary-btn" onclick="testQuestionSample(this.closest('.question'))">Test full question</button>
        <div class="qTestResult"></div>
      </div>
    </div>
  `;
  container.appendChild(div);

  // Make this new question draggable
  makeQuestionDraggable(div);

  // Options: MC
  const optContainer = div.querySelector('.option-list');
  if (q && q.type === 'mc' && Array.isArray(q.options)) {
    let correctIndex = -1;
    if (q.rubric && q.rubric.length > 0 && q.rubric[0].check) {
      const pattern = q.rubric[0].check.toLowerCase();
      correctIndex = q.options.findIndex(o => pattern.includes((o || '').toLowerCase()));
    }
    q.options.forEach((optText, idx) => {
      addOptionRow(optContainer, {
        text: optText,
        correct: idx === correctIndex
      });
    });
  } else if (!q) {
    addOptionRow(optContainer);
  }

  // Rubric for non-MC
  const rubricList = div.querySelector('.rubric-list');
  if (q && q.rubric && q.type !== 'mc') {
    q.rubric.forEach(r => addRubricRow(rubricList, r));
  } else if (!q || (q && q.type !== 'mc')) {
    addRubricRow(rubricList);
  }

  // Ensure correct show/hide
  const select = div.querySelector('.qType');
  toggleOptionsRubric(select);

  // Auto-suggest ID on text blur + keep header label in sync
  const qText = div.querySelector('.qText');
  const qIdInput = div.querySelector('.qId');
  const headerTitleEl = div.querySelector('.qHeaderTitle');

  qText.addEventListener('blur', () => suggestQuestionId(div));
  qIdInput.addEventListener('input', () => {
    headerTitleEl.textContent = qIdInput.value || 'Question';
  });
}

function duplicateQuestion(btn) {
  const qDiv = btn.closest('.question');
  const container = qDiv.parentElement;
  const clone = qDiv.cloneNode(true);
  clone.classList.add('collapsed');
  const idInput = clone.querySelector('.qId');
  const headerTitleEl = clone.querySelector('.qHeaderTitle');
  const collapseBtn = clone.querySelector('.collapse-btn');

  if (idInput) idInput.value = (idInput.value || '') + '_copy';
  if (headerTitleEl && idInput) headerTitleEl.textContent = idInput.value || headerTitleEl.textContent;
  if (collapseBtn) collapseBtn.textContent = 'â–¸';

  const qIdInput = clone.querySelector('.qId');
  if (qIdInput && headerTitleEl) {
    qIdInput.addEventListener('input', () => {
      headerTitleEl.textContent = qIdInput.value || 'Question';
    });
  }

  // make duplicated question draggable
  makeQuestionDraggable(clone);

  container.insertBefore(clone, qDiv.nextSibling);
}

function suggestQuestionId(qDiv) {
  const idInput = qDiv.querySelector('.qId');
  if (!idInput || idInput.value.trim()) return;
  const text = qDiv.querySelector('.qText').value || '';
  let base = text.toLowerCase()
    .replace(/[^a-z0-9]+/g, '_')
    .replace(/^_+|_+$/g, '')
    .slice(0, 40);
  if (!base) base = 'q' + Date.now();
  idInput.value = base;
  const headerTitleEl = qDiv.querySelector('.qHeaderTitle');
  if (headerTitleEl) headerTitleEl.textContent = base;
}

function toggleOptionsRubric(select) {
  const qDiv = select.closest('.question');
  const isMc = select.value === 'mc';
  const optionsDiv = qDiv.querySelector('.options');
  const rubricDiv = qDiv.querySelector('.rubric');
  if (optionsDiv) optionsDiv.style.display = isMc ? 'block' : 'none';
  if (rubricDiv) rubricDiv.style.display = isMc ? 'none' : 'block';
}

// ---------- Image drag/drop + file ----------
function imageDropClick(dropDiv) {
  const fileInput = dropDiv.querySelector('.qImageFile');
  if (fileInput) fileInput.click();
}

function handleImageFileSelect(input) {
  const file = input.files[0];
  if (!file) return;
  const qDiv = input.closest('.question');
  if (!qDiv) return;
  const imgInput = qDiv.querySelector('.qImage');
  if (imgInput) {
    imgInput.value = file.name;
  }
}

function handleImageDragOver(event) {
  event.preventDefault();
  const dropDiv = event.currentTarget;
  dropDiv.classList.add('dragover');
}

function handleImageDragLeave(event) {
  event.preventDefault();
  const dropDiv = event.currentTarget;
  dropDiv.classList.remove('dragover');
}

function handleImageDrop(event) {
  event.preventDefault();
  const dropDiv = event.currentTarget;
  dropDiv.classList.remove('dragover');
  const files = event.dataTransfer.files;
  if (!files || !files.length) return;
  const file = files[0];
  const qDiv = dropDiv.closest('.question');
  if (!qDiv) return;
  const imgInput = qDiv.querySelector('.qImage');
  if (imgInput) {
    imgInput.value = file.name;
  }
}

// ---------- Options (MC answers) ----------
function addOptionRow(container, opt = null) {
  const div = document.createElement('div');
  div.className = 'option-row';
  div.innerHTML = `
    <span class="remove" onclick="this.parentElement.remove()">âœ–</span>
    <label>Option text
      <input type="text" class="optText" value="${opt ? (opt.text || opt) : ''}">
    </label>
    <label>
      <input type="checkbox" class="optCorrect" ${opt && opt.correct ? 'checked' : ''}>
      Correct answer
    </label>
  `;
  container.appendChild(div);
}

// ---------- Flags explanation helper ----------
function updateFlagExplanation(selectEl) {
  const row = selectEl.closest('.rubric-row');
  const textInput = row.querySelector('.rFlags');
  const explanation = row.querySelector('.flagExplanation');
  const value = selectEl.value;

  if (value === "custom") {
    textInput.style.display = "block";
    if (!textInput.value.trim()) {
      textInput.value = "";
    }
  } else {
    textInput.style.display = "none";
    textInput.value = value;
  }

  switch (value) {
    case "i":
      explanation.textContent = "Matches answers regardless of UPPER/lower case.";
      break;
    case "im":
      explanation.textContent = "Multi-line mode: ^ and $ match each line. Case is ignored.";
      break;
    case "is":
      explanation.textContent = "Dot-all: .* can span across line breaks. Case is ignored.";
      break;
    case "":
      explanation.textContent = "Case-sensitive exact match. Rarely needed for student answers.";
      break;
    case "custom":
      explanation.textContent = "Advanced: enter flags manually (e.g. im, ig, ims).";
      break;
    default:
      explanation.textContent = "";
  }
}

// Update preview text for a rubric row
function updateRubricPreview(row) {
  const preview = row.querySelector('.rPreview');
  if (!preview) return;

  const easy = row.querySelector('.rEasy')?.value.trim() || '';
  const adv = row.querySelector('.rCheck')?.value.trim() || '';

  if (adv) {
    preview.textContent = `Using advanced regex: ${adv}`;
  } else if (easy) {
    const parts = easy.split(',').map(s => s.trim()).filter(Boolean);
    if (parts.length) {
      // NEW: explain alternation behaviour
      preview.textContent = `Will match if the answer contains any of: ${parts.join('; ')}`;
    } else {
      preview.textContent = '';
    }
  } else {
    preview.textContent = '';
  }
}

// ---------- Rubric rows (layman-friendly) ----------
function addRubricRow(container, r = null) {
  const div = document.createElement('div');
  div.className = 'rubric-row';
  div.innerHTML = `
    <span class="remove" onclick="this.parentElement.remove()">âœ–</span>

    <label>Points (for this rule)
      <input type="number" class="rPoints" value="${r ? (r.points || 1) : 1}">
    </label>

    <label>Keywords/phrases (matches if ANY are mentioned)
      <input type="text" class="rEasy" placeholder="e.g. eye injury, blindness, flying particles">
    </label>

    <label>Advanced regex (optional â€“ use instead of keywords)
      <input type="text" class="rCheck" value="${r ? (r.check || '') : ''}"></label>

    <label>Flags (how matching works)</label>
    <select class="rFlagsSelect" onchange="updateFlagExplanation(this)">
      <option value="i" selected>Ignore case (recommended)</option>
      <option value="im">Ignore case + multi-line (^ matches each line)</option>
      <option value="is">Ignore case + dot-all (.* across lines)</option>
      <option value="">Exact matching (case-sensitive)</option>
      <option value="custom">Custom (advanced)</option>
    </select>

    <input type="text" class="rFlags" style="display:none" placeholder="Enter flags e.g. im">

    <div class="flagExplanation" style="font-size:11px; color:#555; margin-top:4px;">
      Matches answers regardless of UPPER/lower case.
    </div>

    <label>Preview
      <div class="rPreview" style="font-size:11px; color:#555; min-height:1em;"></div>
    </label>
  `;
  container.appendChild(div);

  // Initialise flags based on existing data (if loading from JSON)
  const select = div.querySelector('.rFlagsSelect');
  const flagsInput = div.querySelector('.rFlags');
  let flags = r && r.flags !== undefined ? r.flags : 'i';

  if (flags === 'i' || flags === 'im' || flags === 'is' || flags === '') {
    select.value = flags;
    flagsInput.value = flags;
    flagsInput.style.display = 'none';
  } else {
    select.value = 'custom';
    flagsInput.value = flags;
    flagsInput.style.display = 'block';
  }
  updateFlagExplanation(select);

  // Hook previews
  const easyInput = div.querySelector('.rEasy');
  const advInput = div.querySelector('.rCheck');
  easyInput.addEventListener('input', () => updateRubricPreview(div));
  advInput.addEventListener('input', () => updateRubricPreview(div));
  updateRubricPreview(div);
}

// Count keyword matches for stats
function countKeywordMatches(row, sample, flags) {
  const easyInputEl = row.querySelector('.rEasy');
  if (!easyInputEl) return { hits: 0, total: 0 };
  const easyInput = easyInputEl.value.trim();
  if (!easyInput) return { hits: 0, total: 0 };

  const parts = easyInput.split(',').map(s => s.trim()).filter(Boolean);
  if (!parts.length) return { hits: 0, total: 0 };

  const cleanFlags = sanitizeFlags(flags || 'i');
  let hits = 0;

  parts.forEach(p => {
    const escaped = p.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    try {
      const re = new RegExp(escaped, cleanFlags);
      if (re.test(sample)) hits++;
    } catch (e) {
      // ignore bad keyword pattern; scoring still based on other items
    }
  });

  return { hits, total: parts.length };
}

// ---------- Test full question (score + keyword matches) ----------
function testQuestionSample(qDiv) {
  const sampleEl = qDiv.querySelector('.qSample');
  const resultEl = qDiv.querySelector('.qTestResult');
  const sample = (sampleEl.value || '').trim();

  if (!sample) {
    resultEl.textContent = 'Please paste or type a sample answer first.';
    return;
  }

  const type = qDiv.querySelector('.qType').value;
  const maxPointsField = parseInt(qDiv.querySelector('.qPoints').value) || 1;
  let totalScore = 0;
  let details = [];

  // ---------- Multiple choice ----------
  if (type === 'mc') {
    const optRows = Array.from(qDiv.querySelectorAll('.option-row'));
    const correctRow = optRows.find(r => r.querySelector('.optCorrect').checked);

    if (!correctRow) {
      resultEl.textContent = 'No correct option selected for this multiple-choice question.';
      return;
    }

    const correctText = correctRow.querySelector('.optText').value.trim();
    if (!correctText) {
      resultEl.textContent = 'Correct option has no text.';
      return;
    }

    const escaped = correctText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    try {
      const re = new RegExp(escaped, 'i');
      const hit = re.test(sample);
      totalScore = hit ? maxPointsField : 0;

      details.push(
        hit
          ? `Matched correct option text: "${correctText}".`
          : `Did not find the exact correct option text. Sample must contain:\n"${correctText}".`
      );
    } catch (e) {
      resultEl.textContent = 'Error in auto-generated pattern for MC: ' + e.message;
      return;
    }

    resultEl.textContent =
      `Score for this sample: ${totalScore} / ${maxPointsField}.\n` +
      details.join(' ');
    return;
  }

  // ---------- Short / long answer ----------
  const rows = Array.from(qDiv.querySelectorAll('.rubric-row'));
  if (!rows.length) {
    resultEl.textContent = 'No rubric rules defined for this question.';
    return;
  }

  let maxRubricPoints = 0;
  let totalKeywords = 0;
  let totalKeywordHits = 0;

  rows.forEach((row, idx) => {
    const pts = parseInt(row.querySelector('.rPoints').value) || 1;
    const adv = row.querySelector('.rCheck').value.trim();
    const easyInput = row.querySelector('.rEasy').value.trim();
    const flags = getFlagsForRow(row);

    if (adv) {
      // Advanced regex rule: single rule with "pts" points
      maxRubricPoints += pts;
      try {
        const re = new RegExp(adv, flags);
        const match = re.test(sample);
        if (match) {
          totalScore += pts;
          details.push(`Rule ${idx + 1}: âœ… advanced regex matched (+${pts}).`);
        } else {
          details.push(`Rule ${idx + 1}: âŒ advanced regex did not match.`);
        }
      } catch (e) {
        details.push(`Rule ${idx + 1}: âš  invalid advanced regex (${e.message}).`);
      }

      // Optional keyword stats even if advanced is used
      if (easyInput) {
        const kw = countKeywordMatches(row, sample, flags);
        if (kw.total) {
          totalKeywords += kw.total;
          totalKeywordHits += kw.hits;
          details[details.length - 1] += ` Keywords matched ${kw.hits}/${kw.total}.`;
        }
      }
    } else if (easyInput) {
      // NEW: treat comma-separated keywords as a single OR regex rule
      const parts = easyInput.split(',').map(s => s.trim()).filter(Boolean);
      if (parts.length) {
        const escapedParts = parts.map(p =>
          p.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        );
        const pattern = '(?:' + escapedParts.join('|') + ')';

        try {
          const re = new RegExp(pattern, flags);
          const match = re.test(sample);
          maxRubricPoints += pts;

          if (match) {
            totalScore += pts;
            details.push(
              `Rule ${idx + 1}: âœ… matched at least one of [${parts.join(', ')}] (+${pts}).`
            );
          } else {
            details.push(
              `Rule ${idx + 1}: âŒ none of [${parts.join(', ')}] were found.`
            );
          }

          // stats for how many of the keywords were hit
          const kw = countKeywordMatches(row, sample, flags);
          if (kw.total) {
            totalKeywords += kw.total;
            totalKeywordHits += kw.hits;
            details[details.length - 1] += ` Keywords matched ${kw.hits}/${kw.total}.`;
          }
        } catch (e) {
          details.push(
            `Rule ${idx + 1}: âš  invalid generated regex from keywords (${e.message}).`
          );
        }
      } else {
        details.push(`Rule ${idx + 1}: no keywords defined.`);
      }
    } else {
      details.push(`Rule ${idx + 1}: skipped (no keywords or regex).`);
    }
  });

  let summary =
    `Score for this sample based on rubric: ${totalScore} / ${maxRubricPoints || 0}.`;

  if (totalKeywords > 0) {
    summary += `\nTotal keyword matches (for info only): ${totalKeywordHits} / ${totalKeywords} across all rules.`;
  }

  resultEl.textContent = summary + '\n' + details.join(' ');
}

// ---------- Collect everything ----------
function collectAll() {
  data.APP_ID = document.getElementById('appId').value.trim();
  data.VERSION = document.getElementById('version').value.trim();
  data.APP_TITLE = document.getElementById('appTitle').value.trim();
  data.APP_SUBTITLE = document.getElementById('appSubtitle').value.trim();
  data.DEADLINE = data.DEADLINE || {};
  data.DEADLINE.day = parseInt(document.getElementById('deadlineDay').value) || 1;
  data.DEADLINE.month = parseInt(document.getElementById('deadlineMonth').value) || 1;
  data.DEADLINE.label = document.getElementById('deadlineLabel').value.trim();

  collectTeachers();

  data.ASSESSMENTS = Array.from(document.querySelectorAll('#assessments > .section')).map(assDiv => {
    const questions = Array.from(assDiv.querySelectorAll('.question')).map(qDiv => {
      const type = qDiv.querySelector('.qType').value;
      const maxPoints = parseInt(qDiv.querySelector('.qPoints').value) || 1;

      const question = {
        id: qDiv.querySelector('.qId').value.trim(),
        text: qDiv.querySelector('.qText').value.replace(/\n/g, '\n'),
        image: qDiv.querySelector('.qImage').value.trim() || "blank.jpg",
        hint: qDiv.querySelector('.qHint').value.trim(),
        type: type,
        maxPoints: maxPoints,
        rubric: []
      };

      if (type === 'mc') {
        const optRows = Array.from(qDiv.querySelectorAll('.option-row'));
        const options = optRows
          .map(r => r.querySelector('.optText').value.trim())
          .filter(o => o);
        question.options = options;

        const correctRow = optRows.find(r => r.querySelector('.optCorrect').checked);
        if (correctRow) {
          const correctText = correctRow.querySelector('.optText').value.trim();
          if (correctText) {
            const escaped = correctText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            question.rubric = [{
              points: maxPoints,
              check: escaped,
              flags: 'i'
            }];
          }
        }
      } else {
        const rubric = [];
        const rows = Array.from(qDiv.querySelectorAll('.rubric-row'));
        rows.forEach(row => {
          const pts = parseInt(row.querySelector('.rPoints').value) || 1;
          const adv = row.querySelector('.rCheck').value.trim();
          const easyInput = row.querySelector('.rEasy').value.trim();
          const flags = getFlagsForRow(row);

          if (adv) {
            // advanced rule as-is
            rubric.push({ points: pts, check: adv, flags });
          } else if (easyInput) {
            // NEW: comma-separated keywords -> single OR regex, one rule
            const parts = easyInput.split(',').map(s => s.trim()).filter(Boolean);
            if (parts.length) {
              const escapedParts = parts.map(p =>
                p.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
              );
              const alternation = '(?:' + escapedParts.join('|') + ')';
              rubric.push({
                points: pts,     // use the "Points" field for this whole rule
                check: alternation,
                flags
              });
            }
          }
        });
        question.rubric = rubric.filter(r => r.check);
      }

      return question;
    });

    return {
      id: assDiv.querySelector('.assId').value.trim(),
      title: assDiv.querySelector('.assTitle').value.trim(),
      subtitle: assDiv.querySelector('.assSubtitle').value.trim(),
      usNumber: assDiv.querySelector('.assUSNumber') ? assDiv.querySelector('.assUSNumber').value.trim() : '',
      usVersion: assDiv.querySelector('.assUSVersion') ? assDiv.querySelector('.assUSVersion').value.trim() : '',
      credits: (() => {
        const v = assDiv.querySelector('.assCredits') ? assDiv.querySelector('.assCredits').value : '';
        return v === '' ? null : parseInt(v) || null;
      })(),
      standardType: assDiv.querySelector('.assType') ? assDiv.querySelector('.assType').value : '',
      questions: questions
    };
  });
}

// ---------- Validation ----------
function validateData(d) {
  const errors = [];
  if (!d.APP_ID) errors.push('APP_ID is empty.');
  if (!d.VERSION) errors.push('VERSION is empty.');

  if (!d.ASSESSMENTS || !d.ASSESSMENTS.length) {
    errors.push('No assessments defined.');
    return errors;
  }

  d.ASSESSMENTS.forEach((ass, ai) => {
    const aLabel = ass.title || ass.id || `Assessment ${ai + 1}`;
    if (!ass.id) errors.push(`${aLabel}: Assessment ID is empty.`);
    if (!ass.questions || !ass.questions.length) {
      errors.push(`${aLabel}: has no questions.`);
      return;
    }
    ass.questions.forEach((q, qi) => {
      const qLabel = `${aLabel} / ${q.id || 'Question ' + (qi + 1)}`;
      if (!q.id) errors.push(`${qLabel}: Question ID is empty.`);
      if (q.type === 'mc') {
        if (!q.options || !q.options.length) {
          errors.push(`${qLabel}: MC question has no options.`);
        }
        if (!q.rubric || !q.rubric.length) {
          errors.push(`${qLabel}: MC question has no correct answer selected.`);
        }
      } else {
        if (!q.rubric || !q.rubric.length) {
          errors.push(`${qLabel}: has no rubric rules.`);
        }
      }
    });
  });

  return errors;
}

// ---------- Generate & Download JSON ----------
function generateJSON() {
  collectAll();
  const errors = validateData(data);
  if (errors.length) {
    alert("Please fix these issues before downloading:\n\n" + errors.join("\n"));
    return;
  }
  const jsonString = JSON.stringify(data, null, 2);
  const blob = new Blob([jsonString], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${data.APP_ID || 'quiz'}_v${data.VERSION || ''}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

// ---------- Autosave ----------
function autosave() {
  if (isLoading) return;
  try {
    collectAll();
    localStorage.setItem('bcats_quiz_builder_draft', JSON.stringify(data));
  } catch (e) {
    console.warn('Autosave failed', e);
  }
}

document.addEventListener('input', autosave);
document.addEventListener('change', autosave);

function clearDraft() {
  if (confirm('Clear saved draft and reset the builder?')) {
    localStorage.removeItem('bcats_quiz_builder_draft');
    location.reload();
  }
}

// ---------- Load JSON from file ----------
function loadJSONFile() {
  const input = document.getElementById('jsonFile');
  const file = input.files[0];
  if (!file) {
    alert('Please choose a JSON file first.');
    return;
  }

  const reader = new FileReader();
  reader.onload = e => {
    try {
      const obj = JSON.parse(e.target.result);
      loadFromData(obj);
      // collapse all assessments/questions after loading
      collapseAllSections();
    } catch (err) {
      console.error(err);
      alert('Invalid JSON file.');
    }
  };
  reader.readAsText(file);
}

// ---------- Populate UI from data ----------
function loadFromData(obj) {
  if (!obj || typeof obj !== 'object') {
    alert('JSON does not look like a quiz data object.');
    return;
  }

  isLoading = true;
  data = obj;

  document.getElementById('appId').value = obj.APP_ID || '';
  document.getElementById('version').value = obj.VERSION || '';
  document.getElementById('appTitle').value = obj.APP_TITLE || '';
  document.getElementById('appSubtitle').value = obj.APP_SUBTITLE || '';

  const deadline = obj.DEADLINE || {};
  document.getElementById('deadlineDay').value = deadline.day || 1;
  document.getElementById('deadlineMonth').value = deadline.month || 1;
  document.getElementById('deadlineLabel').value = deadline.label || '';

  const tContainer = document.getElementById('teachers');
  tContainer.innerHTML = '';
  (obj.TEACHERS || []).forEach(t => addTeacher(t));

  const aContainer = document.getElementById('assessments');
  aContainer.innerHTML = '';
  (obj.ASSESSMENTS || []).forEach(a => addAssessment(a));

  // make all existing questions draggable (just in case)
  document.querySelectorAll('.question').forEach(q => makeQuestionDraggable(q));

  isLoading = false;
}

// ---------- Initial setup / restore draft ----------
(function init() {
  const draft = localStorage.getItem('bcats_quiz_builder_draft');
  if (draft) {
    try {
      const obj = JSON.parse(draft);
      loadFromData(obj);
      collapseAllSections(); // start collapsed when restoring draft (assessments/questions)
      return;
    } catch (e) {
      console.warn('Could not load draft, starting fresh.');
    }
  }

  addTeacher({id:"RY", name:"Mr Reynolds", email:"ry@pukekohehigh.school.nz"});
  addTeacher({id:"RNR", name:"Mr Ranson", email:"rnr@pukekohehigh.school.nz"});
  addTeacher({id:"Other", name:"Other Teacher", email:"technology@pukekohehigh.school.nz"});
  addAssessment();
  collapseAllSections(); // assessments/questions collapsed on fresh load
})();
</script>

</body>
</html>
